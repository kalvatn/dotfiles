#!/bin/bash

set -e

DOTFILE_ROOT="$(pwd)"
if [ "$DOTFILE_ROOT" != "$HOME/dotfiles" ]; then
  echo "must be run from $HOME/dotfiles"
  exit 1
fi
ln -sf "$DOTFILE_ROOT/.aliases" "$HOME"
ln -sf "$DOTFILE_ROOT/.variables" "$HOME"
ln -sf "$DOTFILE_ROOT/.functions" "$HOME"
source "$HOME/.functions"

opts="vhlu"

function cmd() {
  basename "$0"
}

function usage() {
  read -r -d '\0' helpstring <<EOM
$(cmd) [OPTION...]
  -v, --verbose | enable verbose output
                | (multiple times for more verbosity,
                | e.g.  -vv will enable DEBUG logging level)
  -l, --loglevel| toggle specific log level (valid values : [ DEBUG, INFO, WARN, ERROR ] )
  -h, --help    | show this help message
  -u, --usage   | show this help message
\0
EOM
  echo "$helpstring" | column -t -s "|"
}

function unknown_option_error() {
  usage
  printf "\nunknown option '$1'\r\n"
  exit 1
}

# https://thepracticalsysadmin.com/building-a-better-bash-script/
# There's two passes here. The first pass handles the long options and any
# short option that is already in canonical form. The second pass uses `getopt`
# to canonicalize any remaining short options and handle them
for pass in 1 2; do
  while [ -n "$1" ]; do
    case $1 in
      --) shift; break;;
      -*)
        case $1 in
          -h|--help| \
          -u|--usage)    usage; exit 0;;
          -v|--verbose)  VERBOSE="$(($VERBOSE + 1))";;
          -l|--loglevel)
            echo "\$1 : $1, \$2 : $2"
            LOGLEVEL="$2"
            shift;;
          --*)           unknown_option_error "$1";;
          -*)
            if [ $pass -eq 1 ]; then
              ARGS="$ARGS $1"
            else
              unknown_option_error "$1"
            fi;;
          esac;;
      *)
        if [ $pass -eq 1 ]; then
          ARGS="$ARGS $1";
        else unknown_option_error $1;
        fi;;
    esac
    shift
  done
  if [ $pass -eq 1 ]; then
    ARGS=`getopt $opts $ARGS`
    if [ $? != 0 ]; then
      usage;
      exit 2;
    fi
    set -- $ARGS
  fi
done

# Handle positional arguments
if [ -n "$*" ]; then
  usage
  printf "\n$(cmd): runaway arguments : $*\r\n"
  exit 1
fi

if [ -z "$LOGLEVEL" ]; then
  if [ -n "$VERBOSE" ]; then
    case "$VERBOSE" in
      1) LOGLEVEL=INFO;;
      *) LOGLEVEL=DEBUG;;
    esac
  fi
fi

if [ -z "$LOGLEVEL" ]; then
  #echo "log level not set, defaulting to WARN (to set: export LOGLEVEL=[DEBUG|INFO|WARN|ERROR])"
  LOGLEVEL=WARN
fi
export LOGLEVEL="$LOGLEVEL"

debug "loglevel debug"
info "loglevel debug"
warn "loglevel debug"
error "loglevel debug"
./scripts/installation/git/install

git submodule update --init

./scripts/installation/vim/install
./scripts/installation/tmux/install
./scripts/installation/shell/zsh/install
exit

ln -fs "$DOTFILE_ROOT/bin" "$HOME"
ln -fs "$DOTFILE_ROOT/.gemrc" "$HOME"
ln -fs "$DOTFILE_ROOT/.my.cnf" "$HOME"
ln -fs "$DOTFILE_ROOT/.notify-osd" "$HOME"
ln -fs "$DOTFILE_ROOT/.asoundrc" "$HOME"
ln -fs "$DOTFILE_ROOT/.xinitrc" "$HOME"
ln -fs "$DOTFILE_ROOT/.Xresources" "$HOME"
ln -fs "$DOTFILE_ROOT/.urxvt" "$HOME"



# warn about missing packages

# linter packages

# bash
[[ -z "$(which shellcheck)" ]] && echo "sudo apt-get install shellcheck" || echo "shellcheck installed"
[[ -z "$(which bashate)" ]] && echo "sudo apt-get install python-pip && sudo pip install bashate" || echo "bashate installed"
# markdown
[[ -z "$(which mdl)" ]] && echo "sudo gem install mdl" || echo "mdl installed"
# pylint
[[ -z "$(which pylint)" ]] && echo "sudo pip install pylint" || echo "pylint installed"


# various other tools
[[ -z "$(which feh)" ]] && echo "sudo apt-get install feh" || echo "feh installed"
[[ -z "$(which scrot)" ]] && echo "sudo apt-get install scrot" || echo "scrot installed"
[[ -z "$(which unclutter)" ]] && echo "sudo apt-get install unclutter" || echo "unclutter installed"
