#!/bin/bash

function setup_formatting() {
  RESET=$(tput sgr0)
  BOLD=$(tput bold)
  UNDERLINE=$(tput smul)
  STANDOUT=$(tput smso)

  RED=$(color 1)
  GREEN=$(color 2)
  YELLOW=$(color 3)
  BLUE=$(color 4)
  PURPLE=$(color 5)
  CYAN=$(color 6)
  WHITE=$(color 7)
  GRAY=$(color 8)
  BRIGHT_RED=$(color 9)
  BRIGHT_YELLOW=$(color 11)
  BRIGHT_WHITE=$(color 15)
}

function color() {
  tput setaf "$1"
}

function feature_check() {
  if [ -t 1 ]; then
    if [ -n "$(tput colors)" ]; then
      setup_formatting
    fi
  fi
}

function rainbow() {
  string="$1"
  color=1
  for (( i=0; i<${#string}; i++ )); do
    echo -n "$STANDOUT$(color $color)${string:$i:1}$RESET"
    if ((++color % 16 == 0)); then
      color=$((color+1))
    fi
  done
  printf "\r\n"
}

function datetime() {
  date +"%Y-%m-%d %H:%M:%S"
}

function abbr_path() {
  ~/dotfiles/scripts/utilities/abbreviate-directory "$1"
}

function get_loglevel_intvalue() {
  case "$1" in
    DEBUG)
      echo 0
      ;;
    INFO)
      echo 1
      ;;
    WARN)
      echo 2
      ;;
    ERROR)
      echo 3
      ;;
    *)
      echo -1
      ;;
  esac
}

function should_log() {
  configured_loglevel="$(get_loglevel_intvalue "$LOGLEVEL")"
  if [ -z "$LOGLEVEL" -o "$configured_loglevel" -eq -1 ]; then
    configured_loglevel=100
  fi
  loglevel="$(get_loglevel_intvalue "$1")"
  if [ ! -z "$loglevel" -a "$loglevel" -ge "$configured_loglevel" ]; then
    return 0
  fi
  return 1
}

function log_unformatted() {
  level="$1"
  message="$2"
  if [ ! -z "$message" ]; then
    if should_log "$level"; then
      logger="$(get_script_path "$0"):$LINENO"
      printf "%s %-5s - %s - %s\n" "$(datetime)" "$level" "$logger" "$message"
    fi
  fi
}

function log() {
  color="$1"
  level="$2"
  message="$3"
  if [ ! -z "$message" ]; then
    if should_log "$level"; then
      logger="$(get_script_path "$0"):$LINENO"

      if [ -n "$(tput colors)" ]; then
        formatted_logger="$(abbr_path "$logger")"
        formatted_message="$GRAY$message$RESET"
        formatted_level="$color$BOLD$UNDERLINE$level$RESET"
        printf "%s %-24s - %s - %s\n" "$(datetime)" "$formatted_level" "$formatted_logger" "$formatted_message"
      else
        log_unformatted "$level" "$message"
      fi
    fi
  fi
}

function info() {
  log "$BLUE" "INFO" "$1"
}

function warn() {
  log "$BRIGHT_YELLOW" "WARN" "$1"
}

function error() {
  log "$BRIGHT_RED" "ERROR" "$1"
}

function debug() {
  log "$WHITE" "DEBUG" "$1"
}


feature_check

function cmdpid() {
  pgrep -f "$1"
}

function symlink() {
  info "creating symlink $(abbr_path $1) -> $(abbr_path $2)"
  ln -sf "$1" "$2"
  exitcode="$?"
  if [ ! "$exitcode" -eq 0 ]; then
    error "ln -sf $1 $2 returned non-zero exit code : $exitcode"
  fi
}

function symlink_to_home() {
  symlink "$1" "$HOME"
}

function get_script_dir() {
  # http://stackoverflow.com/questions/59895/can-a-bash-script-tell-what-directory-its-stored-in/246128#246128
  # get_script_dir "${BASH_SOURCE[0]}" in calling script
  SOURCE="$1"

  # resolve $SOURCE until the file is no longer a symlink
  while [ -h "$SOURCE" ]; do
    DIR="$( cd -P "$( dirname "$SOURCE" )" && pwd )"
    SOURCE="$(readlink "$SOURCE")"

    # if $SOURCE was a relative symlink, we need to resolve it relative to the path where the symlink file was located
    [[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE"
  done
  DIR="$( cd -P "$( dirname "$SOURCE" )" && pwd )"
  echo "$DIR"
}

function get_script_path() {
  echo "$(get_script_dir "$1")/$(basename "$1")"
}

# test-colors and formatting
function test_colors() {
  if [ -t 1 ]; then
    echo "is terminal"
    num_colors="$(tput colors)"
    if [ -n "$num_colors" ]; then
      echo "${UNDERLINE}underline$RESET"
      echo "${BOLD}bold$RESET"
      echo "${STANDOUT}standout$RESET"
      for i in $(seq 1 8); do
        echo "$(color $i)Color $i$RESET"
      done
      echo "$num_colors colors, "$(rainbow "$(echo -e {a..z})$(echo -e {1..10})")""

      lorem_ipsum="Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua."
      debug "$lorem_ipsum"
      info "$lorem_ipsum"
      warn "$lorem_ipsum"
      error "$lorem_ipsum"

      log_unformatted "DEBUG" "unformatted"
      log_unformatted "INFO" "unformatted"
      log_unformatted "WARN" "unformatted"
      log_unformatted "ERROR" "unformatted"
    fi
  else
    echo "not a terminal"
  fi
}
